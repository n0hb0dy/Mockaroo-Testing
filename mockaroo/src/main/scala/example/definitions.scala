package example

import example.API._

object definitions {

    var counter = 0; // For unique ID's
    var typeCounter = new Array[Int](4); // Each element holds the current counter for its respective msgType
    var maxSize = new Array[Int](4);
    val rand = scala.util.Random;
    var stringOut = "";
    var input = "";
    

    // Function: Send 10-50 msgs to different topics every 2 seconds. Each message generated by the producer app.
    var msgTypes = Array("Qualified_Lead", "Contact_Attempts", "Screening", "Offers"); // The topics
    var msgCounter = 1;
    // Generation of the first generation of tables.
    val recruiterStrArr = recruiterData() // Same Recruiter will stay
    var qlStrArr = qlData()
    val screenerStrArr = screenerData() // Same table will stay
    var offerStrArr = offerData()
    var screeningStrArr = screeningData()
    var caStrArr = caData()

    var typeMsg = 0;

    // Allowing for dynamic size of each array
    maxSize(0) = qlStrArr.length;
    maxSize(1) = caStrArr.length;
    maxSize(2) = screeningStrArr.length;
    maxSize(3) = offerStrArr.length;
    
    // Testing
    var stop = false;
    // Generation of ID 
    var ql_id = 0;
    var sentType = 0; // Regulate to the topic sent
    

    // Extracting one string to send. Appending if needed (QL ID attachment). Call the array function when at the end.
    def messageGenerator(arr: Array[String]): String = {
        stringOut = arr(typeCounter(typeMsg));
        stringOut = stringOut.replace("\"ql_id\":1","\"ql_id\":" + ql_id)
        typeCounter(typeMsg) = typeCounter(typeMsg) + 1; // Going down the array for each entry
        stringOut
    }

    def chanceNextMessage(typ: Int): Int = {


        val nextQ = rand.nextInt(100);
        if(nextQ > 40) // 40% chance of another contact before proceeding
            return typ + 1;
        return typ
        
    }

}
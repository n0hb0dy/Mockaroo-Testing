package example


import org.apache.kafka.common.serialization.StringSerializer

// Kafka imports
import java.util.Properties
import org.apache.kafka.clients.producer.{KafkaProducer, ProducerRecord}

//Project imports
import example.API._

object mock {

  def main(args: Array[String]): Unit = {
    // Declartion of properties
    val props2: Properties = new Properties();
    
    props2.put("bootstrap.servers", "sandbox-hdp.hortonworks.com:6667")
    props2.put("acks", "all")

    props2.put(
      "key.serializer",
      "org.apache.kafka.common.serialization.StringSerializer"
    )
    props2.put(
      "value.serializer",
      "org.apache.kafka.common.serialization.StringSerializer"
    )

    val producer = new KafkaProducer[String, String](props2);


    var counter = 0; // For unique ID's
    var typeCounter = new Array[Int](4); // Each element holds the current counter for its respective msgType
    var maxSize = new Array[Int](4);
    val rand = scala.util.Random;
    var stringOut = "";
    var input = "";
    

    // Function: Send 10-50 msgs to different topics every 2 seconds. Each message generated by the producer app.
    var msgTypes = Array("Qualified Lead", "Contact Attempts", "Screening", "Offers"); // The topics
    var msgCounter = 1;
    // Generation of the first generation of tables.
    val recruiterStrArr = recruiterData() // Same Recruiter will stay
    var qlStrArr = qlData()
    val screenerStrArr = screenerData() // Same table will stay
    var offerStrArr = offerData()
    var screeningStrArr = screeningData()
    var caStrArr = caData()

    var typeMsg = 0;

    // Allowing for dynamic size of each array
    maxSize(0) = qlStrArr.length;
    maxSize(1) = caStrArr.length;
    maxSize(2) = screeningStrArr.length;
    maxSize(3) = offerStrArr.length;
    
    // Testing
    var stop = false;

    // Whats left: randomize the msg sent, randomize the type of msg sent, wait 2 secs
    try {
      while(!stop) {
        println("Next Iteration:\n")

          var numMsg = rand.nextInt(40) + 10; // Random number stating the amount of msgs generated from 10 to 50 max
          //var numMsg = rand.nextInt(3) + 2; // Delete after testing code
          for(i <- 0 until numMsg) {
            println("We are at : " + msgCounter)
            
            //var typeMsg = rand.nextInt(3); // Decides the type of msg (starts at 0). Might need to be changed to sequential.
              // Generation of data. A string will be taken from the struct to be sent after.What 
              if(typeMsg == 0) { // For QL
              println("Generating QL...")
              // Extracting one string to send. Appending if needed (QL ID attachment). Call the array function when at the end.
                if(typeCounter(typeMsg) != maxSize(typeMsg)) {
                  stringOut = qlStrArr(typeCounter(typeMsg)); // Output the current string in queue
                  println(stringOut);
                  typeCounter(typeMsg) = typeCounter(typeMsg) + 1; // Going down the array for each entry
                  typeMsg = typeMsg + 1;
                }
                else {
                  //qlStrArr = qlData(); // Reset the array
                  stringOut = qlStrArr(0);
                  typeCounter(typeMsg) = 1; // resets the counter
                  typeMsg = typeMsg + 1; // Continues on to the next type msg
                }
                //stringOut = ""; // The output string
              }
              else if(typeMsg == 1) { // For CA
                if(typeCounter(typeMsg) != maxSize(typeMsg)) {
                  stringOut = caStrArr(typeCounter(typeMsg));
                  println(stringOut);
                  typeCounter(typeMsg) = typeCounter(typeMsg) + 1; // Going down the array for each entry
                  var nextQ = rand.nextInt(100);
                  if(nextQ > 40) // 40% chance of another contact before proceeding
                    typeMsg = typeMsg + 1;
                }else{
                  //caStrArr = caData();
                  stringOut = caStrArr(0);
                  typeCounter(typeMsg) = 1;
                  var nextQ = rand.nextInt(100);
                  if(nextQ > 40) // 40% chance of another contact before proceeding
                    typeMsg = typeMsg + 1;
                }
                //stringOut = "";
              }
              else if(typeMsg == 2) { // For Screening
                if(typeCounter(typeMsg) != maxSize(typeMsg)) {
                  stringOut = screeningStrArr(typeCounter(typeMsg));
                  println(stringOut);
                  typeCounter(typeMsg) = typeCounter(typeMsg) + 1; // Going down the array for each entry
                  var nextQ = rand.nextInt(100);
                  if(nextQ > 40) // 40% chance of another screening before proceeding (might need more random if they get an offer)
                    typeMsg = typeMsg + 1; // Right now, guranteed to get an offer eventually
                }else{
                  //screeningStrArr = screeningData();
                  stringOut = screeningStrArr(0);
                  typeCounter(typeMsg) = 1;
                  var nextQ = rand.nextInt(100);
                  if(nextQ > 40) // 40% chance of another screening before proceeding (might need more random if they get an offer)
                    typeMsg = typeMsg + 1; // Right now, guranteed to get an offer eventually
                }
                //stringOut = "";
              }
              else if(typeMsg == 3) { // For offers (python here smh)
                if(typeCounter(typeMsg) != maxSize(typeMsg)) {
                  stringOut = offerStrArr(typeCounter(typeMsg));
                  println(stringOut);
                  typeCounter(typeMsg) = typeCounter(typeMsg) + 1; // Going down the array for each entry
                  typeMsg = 0;
                } else{
                  //offerStrArr = offerData();
                  stringOut = offerStrArr(0);
                  typeCounter(typeMsg) = 1;
                  typeMsg = 0; // Offer
                }
                //stringOut = "";
              }
              else {
                println("RIPPPPPPPPPPP")
              }
              // Sending Data
              // val msg = new ProducerRecord[String, String]( // Lets start over with this one. go for it
              //     msgTypes(typeMsg), // Topic for the msg
              //     msgCounter.toString, // ID for the msg
              //     stringOut // Json string
              //     // So we migrate this block of code to each if-else statement?
              // )
              // producer.send(msg); // sends the msg to the topic
              msgCounter = msgCounter + 1 // update global msg counter

              // val metadata = producer.send(msg)
              // printf(
              //   s"sent record(key=%s value=%s) " +
              //     s"meta(partition=%d, offset=%d)\n",
              //   msg.key(),
              //   msg.value()
              // )

              // Sleep
              Thread.sleep(2000)
          }
          println("Exit? yes(1) ")
          var exit = scala.io.StdIn.readInt();
          if(exit == 1)
            stop = true;
      }
    } catch {
      case e: Exception => e.printStackTrace()
    } finally {
      producer.close() // Closes
    }
  }
}


//Resting Corner (for tired cursors !!!) wtf
//+_+_+_| |_+_+_+//
//+_+_+_| |_+_+_+//
//+_+_+_| |_+_+_+//
//+_+_+_| |_+_+_+//
//+_+_+_| |_+_+_+//
//+_+_+_| |_+_+_+//

// --------------------
// ~(^_^)~   ~(^_^)~
//(0-o)